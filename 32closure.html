<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
    // function randomString(length){
    //     var result = '';
    //     var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
    //     var charactersLength = characters.length;
    //     for(var i = 0; i < length; i++){
    //         result += characters.charAt(Math.floor(Math.random()*charactersLength))
    //     }
    //     return result;
    // }

    
    // function getData(){
    //     var demoData = [];
    //     for(let i = 0; i < 1000 ; i++){
    //         demoData.push(randomString(1000))
    //     }
    //     setTimeout(function(){
    //         demoData;
    //     },10000);
    // }
    // getData();
    /*函式內的變數記憶體空間在函式執行完畢後會被釋放掉*/
    /*但如果子函式有參照父函式裡的變數，父函式裡的變數空間就不會被消掉*/
    /*所謂閉包，就是指當函式內部的函式被回傳後，除了自己本身的程式碼外，也可以透過範圍鍊取得當時函式內部環境的變數值，由於呼叫函式以前範圍鍊就建立了，因此有了可以傳值給外部的功能
    閉包的好處是避免全域變數可能會造成無可預期的錯誤，比方被覆蓋等等。
    */
    // function storeMoney(){
    //     var money = 1000;
    //     return function(price){
    //         money = money + price;
    //         return money;
    //     }
    // }
    // console.log(storeMoney()(1000));//這裡storeMoney()內的var不會在函式結束後被削掉，因為有參照。
    // var MingMoney = storeMoney();
    // console.log("MingMoney: " + MingMoney(100));//因為記憶體空間不會被釋放，每呼叫一次MingMoney裡的money數值會不斷上升
    // console.log("MingMoney: " + MingMoney(100));
    // console.log("MingMoney: " + MingMoney(100));

    // var jayMoney = storeMoney();//jayMoney與MingMoney回傳的是不同的money
    // console.log("jayMoney: " + jayMoney(1000));
    // console.log("jayMoney: " + jayMoney(1000));
    // console.log("jayMoney: " + jayMoney(1000));

    /*MingMoney和jayMoney雖然都參照money，但使用的卻是不同的money的記憶體空間*/

    //演算法書裡案例p.58
    function Queue(){
        var items= [];
        this.enquenue = function(element){
            items.push(element);
        };
        this.dequeue = function(){
            return items.shift();
        };
        this.front = function(){
            return items[0];
        };
        this.isEmpty = function(){
            return items.length == 0;
        };
        this.clear = function(){
            items = [];
        };
        this.size = function(){
            return items.length;
        };
        this.print = function(){
            console.log(items.toString());
        };
    };

    var queue = new Queue();
    console.log(queue);
    console.log(queue.isEmpty());
    
    //添加一些元素
    queue.enquenue('John');
    queue.enquenue('Jack');

    queue.enquenue('Camila');

    //執行一些其他命令
    queue.print();
    console.log(queue.size());
    
    </script>
</body>
</html>