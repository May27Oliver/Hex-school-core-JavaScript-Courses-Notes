<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<script>
    // var message="Hello World!";
    // function log(){
    //     console.log(message);
    //     var message="Hey~Hey";
    //     console.log(message);
    // }
    // log();
    /*==================變數、宣告、作用域與執行背景，例一：===========================*/
    // function b() {
	// var myVar;
    //     console.log(myVar);
    // }

    // function a() {
    //     var myVar = 2;
    //     console.log(myVar);
    //     b();
    // }

    // var myVar = 1;
    // console.log(myVar); 
    // a(); 

    /*執行步驟：
    1.首先電腦先創造全域執行環境。
    2.函式a、b被設定進記憶體(但還沒被呼叫執行其內容)變數myVar也被創造設定進記憶體，並且它是全域變數，它的全域是瀏覽器(window)。
    3.接著在執行階段，賦值1給myVar。
    4.接著console.log(myVar); 印出1。
    5.接著執行(呼叫)a函式。
    6.此時函式a執行環境被創造出來。
    7.在函式a的執行環境中，創造了一個函式a裡的區域變數myVar。
    8.函式a的變數myVar被賦值2。
    9.console.log印出函式a的變數myVar 顯示是2。
    10.接著執行(呼叫)b函式。
    11.此時函式b執行環境被創造出來。
    12.在函式b的執行環境中，創造了一個函式b裡的區域變數myVar。
    13.console.log印出函式b的變數myVar，顯示是undefined(因為我們沒賦值給它)。
    
    所以雖然myVar被宣告了3次，但因為它都在不同的執行環境中，所以這3個其實是不同的變數。
    如果我們在剛剛的程式a(); 下面再加一行console.log(myVar);
    執行後回發現重新印出myVar仍然顯示1，因為這個myVar就是原本全域的變數myVar，代表其實他沒有被覆蓋掉。
    */

    /*==========================例二=============================*/
    function a() {
	var myVar = 2;
        b();
    }

    function b() {
        console.log(myVar);//1
        console.log(this)//window
    }

    var myVar = 1;
    a(); 

    /*
    console.log(myVar);這段程式碼是在function b中
    b這個函式中根本沒有宣告變數
    那為何會印出1而非undefined?

    當函式中使用到沒有定義的變數時，JS會接著到外部環境尋找(外部參照)，注意這裡的外部環境不是指呼叫這個函式的執行環境，
    而是指定義宣告這個函式的外部環境。
    函式b是在全域環境定義，在函式a中呼叫執行，既然是向定義環境找，所以函數b的外部環境就是全域環境，而不是函式a，
    故它就找到全域環境的變數myVar，最後印出1。
    */




</script>
</body>
</html>